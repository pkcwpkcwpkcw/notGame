# Step 7: 회로 시뮬레이션 엔진 요구사항 명세서

## 1. 개요

### 1.1 목적
본 문서는 NOT Gate 게임의 Step 7 구현을 위한 상세 요구사항을 정의합니다. 회로 시뮬레이션 엔진은 게임의 핵심 기능으로, 사용자가 배치한 NOT 게이트와 와이어를 통해 신호가 전파되고 처리되는 과정을 시뮬레이션합니다.

### 1.2 범위
- 신호 전파 기본 로직
- NOT 게이트 신호 처리
- 와이어를 통한 신호 전달
- 0.1초 게이트 딜레이 구현
- 신호 루프 감지

### 1.3 관련 문서
- [GAME_SPEC.md](GAME_SPEC.md): 게임 기능 명세
- [CPP_ARCHITECTURE.md](CPP_ARCHITECTURE.md): C++ 아키텍처 설계
- [ROADMAP.md](ROADMAP.md): 개발 로드맵

## 2. 기능 요구사항

### 2.1 신호 전파 기본 로직 (FR-7.1)

#### 2.1.1 신호 상태 관리
- **FR-7.1.1**: 시스템은 각 연결점(게이트 입출력, 와이어)의 신호 상태를 0(OFF) 또는 1(ON)으로 관리해야 한다
- **FR-7.1.2**: 신호 상태는 실시간으로 업데이트되며, 변경사항은 즉시 다음 연결점으로 전파되어야 한다
- **FR-7.1.3**: 초기 상태에서 모든 신호는 0(OFF)이어야 한다

#### 2.1.2 신호 전파 순서
- **FR-7.1.4**: 신호는 출력에서 입력으로 단방향으로만 전파되어야 한다
- **FR-7.1.5**: 동시에 여러 신호가 변경될 경우, 위상학적 정렬(Topological Sort)에 따라 순서대로 처리해야 한다
- **FR-7.1.6**: 신호 전파는 프레임당 한 번씩 업데이트되어야 한다

### 2.2 NOT 게이트 신호 처리 (FR-7.2)

#### 2.2.1 NOT 연산
- **FR-7.2.1**: NOT 게이트는 3개의 입력 신호를 받아 하나의 출력을 생성해야 한다
- **FR-7.2.2**: 출력 신호는 다음 규칙을 따라야 한다:
  - 모든 입력이 0 → 출력 1
  - 하나 이상의 입력이 1 → 출력 0
- **FR-7.2.3**: 연결되지 않은 입력 포트는 0으로 간주해야 한다

#### 2.2.2 신호 처리 타이밍
- **FR-7.2.4**: 입력 신호 변경 감지 후 0.1초 후에 출력이 변경되어야 한다
- **FR-7.2.5**: 딜레이 중 새로운 입력이 들어오면 타이머가 재시작되어야 한다

### 2.3 와이어를 통한 신호 전달 (FR-7.3)

#### 2.3.1 즉시 전달
- **FR-7.3.1**: 와이어는 신호를 지연 없이 즉시 전달해야 한다
- **FR-7.3.2**: 와이어는 양방향 신호 전달을 지원해야 한다
- **FR-7.3.3**: 하나의 와이어에 여러 출력이 연결된 경우, OR 연산으로 처리해야 한다

#### 2.3.2 연결 검증
- **FR-7.3.4**: 와이어는 유효한 연결(게이트 포트 또는 다른 와이어)만 허용해야 한다
- **FR-7.3.5**: 끊어진 연결은 신호를 전파하지 않아야 한다

### 2.4 게이트 딜레이 구현 (FR-7.4)

#### 2.4.1 타이머 관리
- **FR-7.4.1**: 각 게이트는 독립적인 딜레이 타이머를 가져야 한다
- **FR-7.4.2**: 타이머는 정확히 0.1초(100ms)로 설정되어야 한다
- **FR-7.4.3**: 타이머는 프레임 독립적으로 동작해야 한다 (deltaTime 사용)

#### 2.4.2 딜레이 동작
- **FR-7.4.4**: 딜레이 중인 게이트는 이전 출력 값을 유지해야 한다
- **FR-7.4.5**: 딜레이 완료 시 새로운 출력 값으로 즉시 변경되어야 한다

### 2.5 신호 루프 감지 (FR-7.5)

#### 2.5.1 순환 의존성 감지
- **FR-7.5.1**: 시스템은 신호 경로에서 순환 의존성을 감지해야 한다
- **FR-7.5.2**: 루프가 감지되면 경고 메시지를 표시해야 한다
- **FR-7.5.3**: 루프가 있어도 시뮬레이션은 계속 동작해야 한다 (발진 허용)

#### 2.5.2 루프 처리
- **FR-7.5.4**: 루프 내의 신호는 게이트 딜레이에 의해 자연스럽게 발진해야 한다
- **FR-7.5.5**: 최대 재귀 깊이를 설정하여 무한 루프를 방지해야 한다

## 3. 성능 요구사항

### 3.1 처리 성능 (PR-7.1)
- **PR-7.1.1**: 100,000개 게이트에서 60 FPS 유지
- **PR-7.1.2**: 1,000,000개 게이트에서 최소 10 FPS 유지 (샌드박스 모드)
- **PR-7.1.3**: 신호 업데이트 시간 < 16ms (60 FPS 기준)

### 3.2 메모리 효율성 (PR-7.2)
- **PR-7.2.1**: 게이트당 메모리 사용량 < 64 bytes
- **PR-7.2.2**: 신호 상태는 비트 배열로 저장 (32개 신호당 4 bytes)
- **PR-7.2.3**: 캐시 라인 정렬을 통한 메모리 접근 최적화

### 3.3 알고리즘 복잡도 (PR-7.3)
- **PR-7.3.1**: 신호 전파: O(V + E) where V=게이트 수, E=연결 수
- **PR-7.3.2**: 루프 감지: O(V + E) using DFS
- **PR-7.3.3**: 타이머 업데이트: O(active_gates)

## 4. 데이터 플로우

### 4.1 입력 데이터
```cpp
struct SimulationInput {
    Circuit* circuit;           // 회로 데이터
    float deltaTime;           // 프레임 시간
    bool isPaused;            // 일시정지 상태
};
```

### 4.2 내부 데이터 구조
```cpp
struct SignalState {
    alignas(64) uint32_t signals[MAX_SIGNALS/32];  // 비트 배열
    std::vector<uint32_t> dirtyList;               // 변경된 신호 목록
};

struct GateTimer {
    float remainingTime;       // 남은 딜레이 시간
    uint8_t pendingOutput;     // 대기 중인 출력 값
    bool isActive;            // 타이머 활성 상태
};
```

### 4.3 출력 데이터
```cpp
struct SimulationOutput {
    SignalState currentState;  // 현재 신호 상태
    std::vector<uint32_t> changedSignals;  // 변경된 신호 목록
    bool hasLoop;             // 루프 감지 여부
};
```

## 5. 인터페이스 정의

### 5.1 주요 클래스 인터페이스
```cpp
class CircuitSimulator {
public:
    // 초기화
    void initialize(Circuit* circuit);
    
    // 시뮬레이션 업데이트
    void update(float deltaTime);
    
    // 신호 상태 조회
    bool getSignalState(uint32_t signalId) const;
    
    // 외부 신호 입력 (퍼즐 모드용)
    void setExternalSignal(uint32_t signalId, bool value);
    
    // 루프 감지
    bool detectLoops();
    
    // 리셋
    void reset();
    
private:
    // 신호 전파
    void propagateSignals();
    
    // 게이트 처리
    void processGates();
    
    // 타이머 업데이트
    void updateTimers(float deltaTime);
};
```

## 6. 오류 처리

### 6.1 예외 상황
- **ERR-7.1**: 순환 의존성 감지 시 경고 로그 출력
- **ERR-7.2**: 무효한 연결 감지 시 해당 연결 무시
- **ERR-7.3**: 메모리 할당 실패 시 시뮬레이션 중단
- **ERR-7.4**: 최대 재귀 깊이 초과 시 해당 경로 처리 중단

### 6.2 복구 메커니즘
- 오류 발생 시 이전 유효 상태로 롤백
- 부분적 오류는 해당 부분만 건너뛰고 계속 진행
- 치명적 오류는 사용자에게 알리고 안전 모드로 전환

## 7. 테스트 요구사항

### 7.1 단위 테스트
- **TEST-7.1**: NOT 게이트 진리표 검증
- **TEST-7.2**: 딜레이 타이머 정확도 (±1ms)
- **TEST-7.3**: 신호 전파 순서 검증
- **TEST-7.4**: 루프 감지 알고리즘 검증

### 7.2 통합 테스트
- **TEST-7.5**: 100개 게이트 연쇄 반응 테스트
- **TEST-7.6**: 복잡한 회로 (1000+ 연결) 동작 검증
- **TEST-7.7**: 다중 루프 시나리오 테스트

### 7.3 스트레스 테스트
- **TEST-7.8**: 100,000 게이트 성능 벤치마크
- **TEST-7.9**: 메모리 누수 검사 (10분 연속 실행)
- **TEST-7.10**: 최악 시나리오 (모든 게이트 동시 변경)

## 8. 기존 시스템 통합

### 8.1 렌더링 시스템 (Step 3)
- 신호 상태를 시각적으로 표현하기 위한 데이터 제공
- 변경된 신호 목록을 렌더러에 전달

### 8.2 입력 처리 시스템 (Step 4)
- 사용자 입력에 의한 외부 신호 변경 처리
- 디버그 모드에서 수동 신호 제어

### 8.3 게이트 배치 시스템 (Step 5)
- 새 게이트 추가 시 시뮬레이션 데이터 구조 업데이트
- 게이트 삭제 시 관련 신호 정리

### 8.4 와이어 연결 시스템 (Step 6)
- 와이어 연결/해제 시 신호 경로 재계산
- 연결 유효성 검증 결과 반영

## 9. 구현 우선순위

### 9.1 Phase 1: 핵심 기능
1. 신호 상태 관리 구조체
2. 기본 NOT 연산 구현
3. 즉시 신호 전파 (딜레이 없이)

### 9.2 Phase 2: 딜레이 시스템
1. 타이머 구조체 구현
2. 0.1초 딜레이 적용
3. deltaTime 기반 업데이트

### 9.3 Phase 3: 고급 기능
1. 루프 감지 알고리즘
2. 위상학적 정렬
3. 성능 최적화

## 10. 검수 기준

### 10.1 기능 검수
- [ ] NOT 게이트가 진리표대로 동작하는가?
- [ ] 0.1초 딜레이가 정확히 적용되는가?
- [ ] 와이어를 통한 신호 전달이 즉시 이루어지는가?
- [ ] 루프가 있는 회로에서 발진이 발생하는가?
- [ ] 대규모 회로에서 신호가 올바르게 전파되는가?

### 10.2 성능 검수
- [ ] 100,000 게이트에서 60 FPS를 유지하는가?
- [ ] 메모리 사용량이 예상 범위 내인가?
- [ ] CPU 사용률이 합리적인가?

### 10.3 통합 검수
- [ ] 렌더링 시스템과 정상 연동되는가?
- [ ] 사용자 입력에 즉각 반응하는가?
- [ ] 게이트/와이어 추가/삭제 시 안정적인가?

## 11. 참고사항

### 11.1 최적화 힌트
- SIMD 명령어 활용 가능 (Step 15에서 구현)
- 비트 연산으로 다수 신호 동시 처리
- 더티 플래그로 불필요한 계산 회피

### 11.2 확장 가능성
- 추후 다른 게이트 타입 추가 고려
- GPU 컴퓨트 셰이더 활용 가능성
- 네트워크 멀티플레이어 지원 대비

### 11.3 제약사항
- 실시간 시뮬레이션 (턴 기반 아님)
- 신호는 디지털 (0 또는 1)만 지원
- 아날로그 신호나 타이밍 다이어그램 미지원