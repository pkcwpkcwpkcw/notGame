# NOT Gate 게임 개발 로드맵

## 개발 순서

### Step 1: 프로젝트 초기 설정
1. CMake 프로젝트 구조 생성(완료)
2. SDL2, OpenGL 기본 윈도우 생성 (완료)
3. 기본 이벤트 루프 구현 (완료)
4. Dear ImGui 통합 (완료)
   - **요구사항**:
     - Dear ImGui 라이브러리를 extern/imgui 서브모듈로 통합
     - SDL2 + OpenGL3 백엔드 설정
     - 기본 ImGui 컨텍스트 초기화 및 종료 처리
     - 프레임별 ImGui 렌더링 파이프라인 구축
   - **기능 명세**:
     - ImGui::CreateContext() / DestroyContext() 라이프사이클 관리
     - ImGui_ImplSDL2_InitForOpenGL() 백엔드 초기화
     - ImGui_ImplOpenGL3_Init() with GLSL version 330
     - SDL2 이벤트를 ImGui로 전달 (ImGui_ImplSDL2_ProcessEvent)
     - 프레임 시작/종료 처리 (NewFrame, Render, RenderDrawData)
   - **테스트 항목**:
     - 데모 윈도우 표시 (ImGui::ShowDemoWindow)
     - 마우스/키보드 입력 정상 처리
     - 한글 입력 지원 확인 (IME)
     - 다중 윈도우 렌더링
     - 도킹(Docking) 기능 활성화
   - **파일 구조**:
     - src/ui/ImGuiManager.h/cpp - ImGui 초기화/종료 관리
     - src/ui/UIContext.h/cpp - UI 상태 및 윈도우 관리
     - CMakeLists.txt 업데이트 - imgui 소스 파일 추가

### Step 2: 데이터 구조 정의
1. Vec2 (위치) 구조체
2. Gate 구조체 (id, type, position, connections)
3. Wire 구조체 (from, to)
4. Circuit 클래스 (gates, wires, signals)
5. Grid 시스템 (좌표 매핑)

### Step 3: 기본 렌더링 시스템
1. OpenGL 셰이더 작성 (vertex, fragment)
2. 그리드 렌더링
3. 게이트 스프라이트 렌더링
4. 와이어 라인 렌더링
5. 카메라 시스템 (pan, zoom)

### Step 4: 입력 처리 시스템
1. 마우스 좌표를 그리드 좌표로 변환
2. 클릭 감지 (게이트, 와이어, 빈 공간)
3. 드래그 시작/종료 감지
4. 키보드 단축키 처리

### Step 5: 게이트 배치 시스템
1. NOT 게이트 팔레트 UI
2. 게이트 선택 상태
3. 그리드에 게이트 배치
4. 게이트 위치 유효성 검사
5. 게이트 삭제 기능

### Step 6: 와이어 연결 시스템
1. 드래그로 와이어 그리기
2. 연결 가능한 포트 하이라이트
3. 와이어 경로 계산 (직선 or 꺾임)
4. 와이어 삭제 기능
5. 연결 유효성 검사

### Step 7: 회로 시뮬레이션 엔진
1. 신호 전파 기본 로직
2. NOT 게이트 신호 처리
3. 와이어를 통한 신호 전달
4. 0.1초 게이트 딜레이 구현
5. 신호 루프 감지

### Step 8: 시각적 피드백
1. 신호 상태 표시 (켜짐/꺼짐)
2. 신호 전파 애니메이션
3. 게이트 활성화 표시
4. 와이어 신호 흐름 표시

### Step 9: 게임 모드 - 퍼즐
1. Level 구조체 정의
2. 레벨 파일 포맷 (JSON)
3. 입력/출력 노드 구현
4. 목표 출력 검증 시스템
5. 레벨 클리어 판정

### Step 10: UI 시스템
1. 메인 메뉴
2. 레벨 선택 화면
3. 게임 내 HUD (사용 게이트 수, 시간)
4. 일시정지 메뉴
5. 설정 화면

### Step 11: 레벨 에디터
1. 에디터 모드 전환
2. 입력/출력 노드 배치
3. 목표 신호 설정
4. 레벨 저장/불러오기
5. 레벨 테스트 모드

### Step 12: 게임 진행 시스템
1. 레벨 잠금/해금
2. 별점 시스템 (게이트 수 기준)
3. 진행도 저장 (파일)
4. 통계 추적 (플레이 시간 등)

### Step 13: 샌드박스 모드
1. 무제한 그리드
2. 다중 선택 (Shift/Ctrl)
3. 복사/붙여넣기
4. 그룹화/언그룹화
5. 서브 회로 저장/불러오기

### Step 14: 성능 최적화 - 1차
1. 기본 프로파일링 설정
2. 렌더링 배칭 구현
3. 더티 플래그 시스템
4. 가시 영역만 렌더링
5. 메모리 풀 구현

### Step 15: 고급 시뮬레이션
1. 비트 연산 최적화
2. 신호 배열을 uint32_t로 변경
3. SIMD 명령어 적용 (AVX2)
4. 병렬 시뮬레이션 준비

### Step 16: 멀티스레딩
1. ThreadPool 구현
2. 회로를 독립 청크로 분할
3. 청크별 병렬 시뮬레이션
4. 스레드 간 동기화
5. 결과 병합

### Step 17: 대규모 회로 지원
1. 공간 분할 자료구조 (QuadTree)
2. LOD (Level of Detail) 시스템
3. 스트리밍 로딩
4. GPU 컴퓨트 셰이더 (옵션)

### Step 18: 추가 기능
1. 실행 취소/다시 실행
2. 자동 저장
3. 회로 검색 기능
4. 디버그 모드 (단계별 실행)
5. 성능 통계 표시

### Step 19: 시각적 개선
1. 부드러운 카메라 이동
2. 게이트 배치 프리뷰
3. 와이어 곡선 렌더링
4. 파티클 효과
5. UI 애니메이션

### Step 20: 최종 완성
1. 전체 기능 테스트
2. 메모리 누수 검사
3. 크래시 버그 수정
4. 성능 최종 최적화
5. 플랫폼별 빌드 테스트

## 구현 우선순위

### 핵심 (필수)
- Step 1-9: 기본 게임 동작
- Step 10-12: 게임 플레이 가능

### 중요
- Step 13-14: 샌드박스 기능
- Step 15-16: 성능 최적화

### 선택
- Step 17-19: 고급 기능
- Step 20: 완성도

## 병렬 작업 가능 항목
- 레벨 디자인 (Step 9 이후)
- 아트 리소스 제작 (Step 3 이후)
- 사운드 효과 (Step 8 이후)