# Step 4: 입력 처리 시스템 기능 명세서

## 1. 시스템 개요

### 1.1 목적
NOT Gate 게임에서 사용자의 마우스 입력을 처리하여 게임 오브젝트(게이트, 와이어)와 상호작용할 수 있도록 하는 입력 처리 시스템

### 1.2 범위
- 마우스 입력 처리 (클릭, 드래그, 이동)
- 좌표계 변환 (스크린 ↔ 월드 ↔ 그리드)
- 오브젝트 선택 및 히트 감지
- 드래그 앤 드롭 지원

### 1.3 시스템 컨텍스트
```
┌─────────────┐     SDL Event      ┌──────────────┐
│    SDL2     │ ─────────────────> │ InputManager │
└─────────────┘                    └──────────────┘
                                           │
                                           ├── Camera (좌표 변환)
                                           ├── Circuit (오브젝트 정보)
                                           └── Game Logic (콜백)
```

## 2. 기능 요구사항

### 2.1 좌표 변환 기능

#### F-2.1.1: 스크린 좌표 → 월드 좌표 변환
- **입력**: 마우스 스크린 좌표 (픽셀 단위)
- **처리**: 카메라의 뷰-프로젝션 역행렬 적용
- **출력**: 월드 공간 좌표 (float 단위)
- **검증**: 윈도우 크기 변경 시에도 정확한 변환

#### F-2.1.2: 월드 좌표 → 그리드 좌표 변환
- **입력**: 월드 공간 좌표
- **처리**: 그리드 크기로 나누고 정수로 변환
- **출력**: 그리드 인덱스 (정수 x, y)
- **검증**: 음수 좌표도 올바르게 처리

#### F-2.1.3: 그리드 좌표 → 월드 좌표 변환
- **입력**: 그리드 인덱스
- **처리**: 그리드 크기 곱셈 및 중심점 계산
- **출력**: 그리드 셀의 중심 월드 좌표
- **검증**: 역변환 시 원래 그리드 좌표 복원

### 2.2 마우스 이벤트 처리

#### F-2.2.1: 마우스 버튼 DOWN 이벤트
- **트리거**: SDL_MOUSEBUTTONDOWN
- **동작**:
  1. 현재 마우스 위치 저장
  2. 클릭된 오브젝트 감지
  3. 드래그 가능 상태로 전환
- **출력**: 클릭 정보 (위치, 대상 오브젝트)

#### F-2.2.2: 마우스 이동 이벤트  
- **트리거**: SDL_MOUSEMOTION
- **동작**:
  1. 현재 마우스 위치 업데이트
  2. 드래그 중이면 드래그 거리 계산
  3. 드래그 임계값(5픽셀) 초과 시 드래그 활성화
- **출력**: 마우스 위치, 드래그 상태

#### F-2.2.3: 마우스 버튼 UP 이벤트
- **트리거**: SDL_MOUSEBUTTONUP
- **동작**:
  1. 드래그 상태 확인
  2. 클릭 또는 드래그 종료 판별
  3. 적절한 콜백 호출
- **출력**: 클릭 또는 드래그 완료 이벤트

### 2.3 히트 감지 기능

#### F-2.3.1: 게이트 히트 감지
- **입력**: 월드 좌표
- **처리**: 
  1. 좌표를 그리드로 변환
  2. 해당 그리드에 게이트 존재 확인
  3. 게이트 바운딩 박스 내부 판별
- **출력**: 게이트 ID 또는 null
- **히트 영역**: 1.0 x 1.0 그리드 셀

#### F-2.3.2: 와이어 히트 감지
- **입력**: 월드 좌표
- **처리**:
  1. 모든 와이어와 거리 계산
  2. 가장 가까운 와이어 선택
  3. 거리 임계값(0.1) 이내 확인
- **출력**: 와이어 ID 또는 null
- **히트 영역**: 와이어 중심선으로부터 0.1 단위

#### F-2.3.3: 포트 히트 감지
- **입력**: 월드 좌표, 게이트 ID
- **처리**:
  1. 게이트의 입력/출력 포트 위치 계산
  2. 각 포트와 거리 계산
  3. 가장 가까운 포트 선택
- **출력**: 포트 타입(입력/출력) 및 인덱스
- **히트 영역**: 0.2 x 0.2 포트 영역

### 2.4 드래그 처리 기능

#### F-2.4.1: 드래그 시작 감지
- **조건**: 
  - 마우스 버튼 누름 상태
  - 이동 거리 > 5픽셀
- **동작**:
  1. 드래그 상태를 Active로 변경
  2. 드래그 시작 콜백 호출
  3. 드래그 대상 저장
- **출력**: DragStartEvent

#### F-2.4.2: 드래그 중 처리
- **조건**: 드래그 상태 Active
- **동작**:
  1. 현재 위치 업데이트
  2. 드래그 경로 계산
  3. 드래그 이동 콜백 호출
- **출력**: DragMoveEvent (delta 포함)

#### F-2.4.3: 드래그 종료 처리
- **조건**: 마우스 버튼 해제
- **동작**:
  1. 최종 위치 확인
  2. 드래그 성공/취소 판별
  3. 드래그 종료 콜백 호출
- **출력**: DragEndEvent

### 2.5 콜백 시스템

#### F-2.5.1: 이벤트 콜백 등록
- **지원 이벤트**:
  - onClick: 단순 클릭
  - onDragStart: 드래그 시작
  - onDragMove: 드래그 중
  - onDragEnd: 드래그 종료
  - onHover: 마우스 호버
- **등록 방법**: std::function 콜백

#### F-2.5.2: 이벤트 데이터 전달
- **클릭 이벤트 데이터**:
  ```cpp
  struct ClickEvent {
      ClickTarget type;     // None, Gate, Wire, Empty
      uint32_t objectId;    // 오브젝트 ID
      glm::ivec2 gridPos;   // 그리드 좌표
      glm::vec2 worldPos;   // 월드 좌표
      int button;           // 마우스 버튼 (0=왼쪽, 1=중간, 2=오른쪽)
  };
  ```

- **드래그 이벤트 데이터**:
  ```cpp
  struct DragEvent {
      DragPhase phase;      // Start, Move, End
      glm::vec2 startPos;   // 시작 위치
      glm::vec2 currentPos; // 현재 위치
      glm::vec2 delta;      // 이동 거리
      ClickTarget target;   // 드래그 대상
      uint32_t targetId;    // 대상 ID
  };
  ```

## 3. 사용자 인터페이스

### 3.1 마우스 커서 피드백

#### F-3.1.1: 커서 모양 변경
- **기본**: 화살표 커서
- **게이트 위**: 손 모양 커서
- **와이어 위**: 십자 커서
- **드래그 중**: 잡는 손 모양
- **연결 가능**: 연결 커서

#### F-3.1.2: 호버 하이라이트
- **게이트 호버**: 외곽선 강조
- **와이어 호버**: 두께 증가
- **포트 호버**: 포트 확대 표시

### 3.2 시각적 피드백

#### F-3.2.1: 선택 표시
- **선택된 게이트**: 색상 변경 또는 외곽선
- **선택된 와이어**: 점선 애니메이션
- **다중 선택**: 선택 박스 표시

#### F-3.2.2: 드래그 피드백
- **드래그 중**: 반투명 고스트 이미지
- **드롭 가능 영역**: 녹색 하이라이트
- **드롭 불가 영역**: 빨간색 하이라이트

## 4. 상태 관리

### 4.1 입력 상태

#### F-4.1.1: 마우스 상태 추적
```cpp
struct MouseState {
    glm::vec2 position;        // 현재 위치
    glm::vec2 lastPosition;    // 이전 프레임 위치
    bool buttons[3];           // 버튼 상태 (L, M, R)
    bool buttonsPressed[3];    // 이번 프레임 눌림
    bool buttonsReleased[3];   // 이번 프레임 해제
    float scrollDelta;         // 휠 스크롤 양
};
```

#### F-4.1.2: 드래그 상태 추적
```cpp
struct DragState {
    bool isDragging;           // 드래그 중 여부
    DragPhase phase;          // None, Potential, Active
    glm::vec2 startPos;       // 드래그 시작 위치
    glm::vec2 currentPos;     // 현재 위치
    float distance;           // 드래그 거리
    float duration;           // 드래그 지속 시간
    ClickTarget targetType;   // 드래그 대상 타입
    uint32_t targetId;        // 드래그 대상 ID
};
```

### 4.2 선택 상태

#### F-4.2.1: 단일 선택
- **저장 정보**: 선택된 오브젝트 타입과 ID
- **갱신 시점**: 클릭 이벤트 시
- **초기화**: ESC 키 또는 빈 공간 클릭

#### F-4.2.2: 다중 선택
- **저장 정보**: 선택된 오브젝트 ID 집합
- **추가**: Shift + 클릭
- **토글**: Ctrl + 클릭
- **범위 선택**: 드래그 선택 박스

## 5. 통합 인터페이스

### 5.1 초기화
```cpp
// InputManager 생성 및 초기화
InputManager* inputManager = new InputManager();
inputManager->setCamera(camera);
inputManager->setCircuit(circuit);
inputManager->setViewport(0, 0, windowWidth, windowHeight);
```

### 5.2 이벤트 처리
```cpp
// SDL 이벤트 루프에서
while (SDL_PollEvent(&event)) {
    // ImGui가 마우스를 사용 중이 아닐 때만 처리
    if (!ImGui::GetIO().WantCaptureMouse) {
        inputManager->handleEvent(event);
    }
}

// 매 프레임 업데이트
inputManager->update(deltaTime);
```

### 5.3 콜백 사용
```cpp
// 클릭 이벤트 처리
inputManager->setOnClick([&](const ClickEvent& e) {
    if (e.type == ClickTarget::Gate) {
        gameState->selectGate(e.objectId);
    } else if (e.type == ClickTarget::Empty) {
        gameState->placeNewGate(e.gridPos);
    }
});

// 드래그로 와이어 연결
inputManager->setOnDragEnd([&](const DragEvent& e) {
    if (e.target == ClickTarget::Wire) {
        gameState->connectWire(e.startPos, e.currentPos);
    }
});
```

## 6. 성능 요구사항

### 6.1 응답 시간
- **마우스 이벤트 처리**: < 0.1ms
- **히트 감지**: < 0.5ms (1000개 오브젝트)
- **좌표 변환**: < 0.01ms

### 6.2 메모리 사용
- **InputManager 인스턴스**: < 1KB
- **이벤트 큐**: < 10KB
- **선택 상태**: O(n) where n = 선택된 오브젝트 수

### 6.3 최적화 전략
- 공간 분할을 통한 히트 감지 가속
- 이벤트 배칭으로 콜백 오버헤드 감소
- 불필요한 좌표 변환 캐싱

## 7. 오류 처리

### 7.1 예외 상황
- **윈도우 외부 클릭**: 무시
- **null 카메라/회로**: 안전하게 처리
- **잘못된 좌표**: 경계값 클램핑

### 7.2 복구 전략
- **드래그 중 포커스 손실**: 드래그 취소
- **빠른 클릭**: 이벤트 큐잉
- **동시 입력**: 우선순위 처리

## 8. 테스트 시나리오

### 8.1 기능 테스트
1. **좌표 변환 정확성**
   - 다양한 줌 레벨에서 클릭 위치 확인
   - 카메라 이동 후 좌표 변환 검증

2. **히트 감지 정확성**
   - 게이트 중심, 모서리, 외부 클릭
   - 와이어 위, 근처 클릭
   - 겹친 오브젝트 우선순위

3. **드래그 동작**
   - 짧은 클릭 vs 드래그 구분
   - 드래그 중 취소 (ESC)
   - 빠른 드래그

### 8.2 통합 테스트
1. **게임 플레이 시나리오**
   - 게이트 선택 → 이동 → 배치
   - 와이어 드래그 연결
   - 다중 선택 후 삭제

2. **엣지 케이스**
   - 윈도우 크기 변경 중 입력
   - 매우 빠른/느린 마우스 이동
   - 동시 다중 버튼 입력

## 9. 향후 확장

### 9.1 추가 입력 장치
- 키보드 단축키 통합
- 터치스크린 지원
- 게임패드 지원

### 9.2 고급 기능
- 제스처 인식
- 입력 매크로
- 커스텀 입력 매핑

### 9.3 접근성
- 마우스 감도 조절
- 버튼 재매핑
- 원버튼 모드